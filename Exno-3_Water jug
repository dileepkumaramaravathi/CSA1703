from collections import deque
print("192372134-A.Dileep Kumar")
def is_goal(x, y, target):
    return x == target or y == target

def bfs(a, b, target):
    visited = set()
    queue = deque()
    queue.append(((0, 0), []))  # (jugA, jugB), path

    while queue:
        (x, y), path = queue.popleft()
        if (x, y) in visited:
            continue
        visited.add((x, y))
        path = path + [(x, y)]

        if is_goal(x, y, target):
            return path

        # All possible operations
        possible_states = [
            (a, y),     # fill jug A
            (x, b),     # fill jug B
            (0, y),     # empty jug A
            (x, 0),     # empty jug B
            (x - min(x, b - y), y + min(x, b - y)),  # A -> B
            (x + min(y, a - x), y - min(y, a - x)),  # B -> A
        ]

        for state in possible_states:
            if state not in visited:
                queue.append((state, path))

    return None

def print_solution(path):
    print("Steps:")
    for step in path:
        print(f"Jug A: {step[0]}L, Jug B: {step[1]}L")
    print(f"Reached target in {len(path) - 1} steps.")

def main():
    print("Water Jug Problem Solver")
    a = int(input("Enter capacity of Jug A: "))
    b = int(input("Enter capacity of Jug B: "))
    target = int(input("Enter target amount: "))

    if target > max(a, b):
        print("Target is greater than both jugs. Impossible!")
        return

    path = bfs(a, b, target)
    if path:
        print_solution(path)
    else:
        print("No solution possible.")

if __name__ == "__main__":
    main()
